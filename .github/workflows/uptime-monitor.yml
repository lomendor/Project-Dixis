# MONITOR-01: Production Uptime Monitor
#
# Runs every 10 minutes to check production health.
# Creates GitHub Issue on failure for fast signal.
#
# Endpoints checked:
# - https://dixis.gr/api/healthz (backend Laravel health)
#
# No external services or secrets required - uses GITHUB_TOKEN.

name: uptime-monitor

on:
  schedule:
    # Every 10 minutes
    - cron: '*/10 * * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (skip issue creation)'
        required: false
        default: 'false'
        type: boolean
      force_fail:
        description: 'Force failure for drill testing (hits invalid endpoint)'
        required: false
        default: 'false'
        type: boolean

concurrency:
  group: uptime-monitor
  cancel-in-progress: true

permissions:
  issues: write
  contents: read

jobs:
  check-production:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Check production healthz
        id: healthz
        run: |
          # Determine endpoint based on force_fail input
          if [ "${{ github.event.inputs.force_fail }}" = "true" ]; then
            ENDPOINT="https://dixis.gr/api/healthz__drill"
            echo "üß™ DRILL MODE: Checking known-bad endpoint $ENDPOINT"
            echo "is_drill=true" >> $GITHUB_OUTPUT
          else
            ENDPOINT="https://dixis.gr/api/healthz"
            echo "üîç Checking $ENDPOINT..."
            echo "is_drill=false" >> $GITHUB_OUTPUT
          fi

          MAX_RETRIES=3
          RETRY_DELAY=5
          TIMEOUT=15

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $attempt/$MAX_RETRIES"

            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout $TIMEOUT \
              --max-time $TIMEOUT \
              "$ENDPOINT") || HTTP_CODE="000"

            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Production healthy (HTTP $HTTP_CODE)"
              echo "status=healthy" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo "‚ö†Ô∏è HTTP $HTTP_CODE - retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
          done

          echo "‚ùå Production UNHEALTHY after $MAX_RETRIES attempts (last: HTTP $HTTP_CODE)"
          echo "status=unhealthy" >> $GITHUB_OUTPUT
          echo "http_code=$HTTP_CODE" >> $GITHUB_OUTPUT
          exit 1

      - name: Create issue on failure
        if: failure() && github.event.inputs.dry_run != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const isDrill = '${{ steps.healthz.outputs.is_drill }}' === 'true';
            const drillPrefix = isDrill ? 'üß™ [DRILL] ' : '';
            const drillNote = isDrill ? '\n\n> ‚ö†Ô∏è **This is a DRILL** - triggered manually with force_fail=true to test alerting.' : '';

            const title = isDrill
              ? 'üß™ [DRILL] Uptime monitor alert test'
              : 'üö® Production DOWN - healthz check failed';

            const body = `## ${isDrill ? 'Alert Drill' : 'Production Health Check Failed'}${drillNote}

            **Time**: ${new Date().toISOString()}
            **Endpoint**: ${isDrill ? 'https://dixis.gr/api/healthz__drill (intentionally invalid)' : 'https://dixis.gr/api/healthz'}
            **Last HTTP Code**: ${{ steps.healthz.outputs.http_code || 'unknown' }}
            **Workflow Run**: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}
            ${isDrill ? '' : `
            ## First Steps
            1. Check if site is accessible: https://dixis.gr
            2. SSH to VPS and check services: \`systemctl status dixis-backend dixis-frontend-launcher\`
            3. Check logs: \`journalctl -u dixis-backend -n 50\`
            4. See runbook: docs/OPS/MONITORING.md
            `}
            ---
            *Auto-created by uptime-monitor workflow${isDrill ? ' (drill mode)' : ''}*`;

            // For drills, use different label to avoid confusion
            const labels = isDrill ? ['drill', 'monitor-test'] : ['production-down', 'urgent'];
            const labelFilter = isDrill ? 'drill' : 'production-down';

            // Check for existing open issue to avoid duplicates
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: labelFilter,
              per_page: 1
            });

            if (issues.length > 0) {
              console.log(`Existing issue #${issues[0].number} already open, adding comment`);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues[0].number,
                body: `‚è∞ ${isDrill ? '[DRILL] ' : ''}Health check failed again at ${new Date().toISOString()}\n\nWorkflow run: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
              });
            } else {
              console.log('Creating new issue');
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels
              });
            }
